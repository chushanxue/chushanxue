### 一、RESTful api

REST全称是`Representational State Transfer`（表现层状态转移）

ful是一个后缀，`充满...特性的`

RESTful api是符合REST风格的api，不是协议、不是标准、不是强制规范，只是一种建议的设计风格

- 统一接口规范
- 提高开发效率
- 降低团队沟通成本

#### 1、名词解释

- 资源

  任何事物，只要有被引用到的必要，它就是一个资源（资源就是你想要操作的数据对象，比如用户、商品、文章）

- 表现层

  资源的表现形式，比如html、json、xml等

- 状态

  记录客户端的信息（比如用户的登录状态，如果不记录客户端的任何信息，那么每次请求都是独立的）

- 转移

  转移是双向的，当你用GET请求时，服务器把资源的状态转移给客户端，当你用POST请求时，客户端把资源的新状态转移给服务器，从而改变服务器上资源的状态

- REST

  REST是一种软件架构风格，让客户端和服务器通过统一的接口，以无状态的方式，互相传递资源的表现层数据，来查询或变更资源状态

#### 2、设计原则

- 客户端发送请求

  - 确定资源（URI，用名词来表示资源，不用动词，比如用名词复数表示资源集合`/users`，如果要操作具体的某一个资源，就加上id`/users/123`，资源还支持嵌套`/users/123/orders`，但不建议嵌套层级太深）
  - 选择动作
    - GET 查询资源
    - POST 创建资源
    - PUT 更新完整资源
    - PATCH 更新部分资源
    - DELETE 删除资源
  - 添加查询条件（可选、通过URI参数表达，而不是复杂的json对象，这样一来URL更清晰，而且浏览器、CDN、代理服务器都能直接根据URL缓存响应结果，不同的URL可以分别缓存，更容易区分）
    - 分页：`/users?page=1&limit=10`
    - 过滤：`/users?name=John&age=30`
    - 排序：`/users?sort=created_at&order=asc`
  - 版本控制（可选）
    - `/api/v1/users`（第一版用户接口）
    - `/api/v2/users`（第二版用户接口）
  - 保持无状态

    客户端每次请求必须包含所有必要信息，服务器不记录客户端状态（比如用户登陆后，不是为了让服务器记住，你已经登陆了，而是每次请求都要带上身份凭证，这么做的好处是，服务器不需要记住谁登录了，每个请求都是独立的，这样一来，想加多少台服务器都行，任何一台都能处理请求，轻松实现负载均衡和横向扩展）

- 服务端返回响应

  - 统一响应格式（json格式，轻量容易解析，不强制，也可以用XML、HTML格式）
  - 返回合适的HTTP状态码，让客户端一眼看出发生了什么

    ![ ](/md/前端工程师应该掌握的服务端思维/1.png)

#### 3、工具使用

- 使用开发框架（Java Spring Boot、Node.js Express）
- 使用IDE插件（vscode的REST Client插件，可以直接在编辑器里测试接口）
- 利用AI生成（RESTful具备明确的设计规范，而AI最擅长处理这种有章可循的东西）
- 生成文档（Swagger、YAPI）

### 二、前端工程师应该掌握的服务端思维

前端的“懂后端”，本质不是技术栈，而是系统感。判断一个人不懂后端，不是“这个人不会写接口”，而是“这个人只站在前端视角做局部最优”。所以，“懂后端” = **在设计和实现前端时，能自动考虑后端的成本、边界和风险**

不用写后端代码，但你需要能和后端讨论设计，并提出合理问题。做到**听懂接口设计、说清数据流、识别责任边界、预期异常情况**，就是**懂后端的前端**

#### 1、接口设计与语义理解

你是否能听懂接口设计的取舍、你是否能提出合理的问题

<mark>关注接口语义和数据稳定性，尽量避免前端承担业务判断或拼装复杂状态。</mark>

- 接口是否稳定（字段会不会变、能否向后兼容）
- 接口是否职责清晰（有没有把业务判断丢给前端、有没有让前端拼业务状态）
- 接口是否服务于前端使用（是否需要多次请求才能完成一个页面、是否过度拆接口）

#### 2、完整数据流意识

<mark>设计前端方案时，先把端到端的数据流想清楚，再决定前端怎么拆状态。</mark>

- 用户操作
- 前端请求
- 后端处理
- 返回数据
- 前端消费
- 异常 & 兜底 (默认接口存在不确定性，在前端做好兜底，而不是假设数据永远正确。)

### 三、项目案例

#### 1、业务分析

以项目【**知识库 QA 管理**】为例，用「端到端数据流 + 状态归属」重拆一遍

从业务的角度看，QA 管理 = 让知识“可被使用、可被维护、可持续演进”，具体可以拆成 4 个核心问题：（从“管理 QA 数据”的角度，业务层面更关注 QA 的生命周期）

- ① QA的来源和可信度（垃圾 QA 会直接拖垮模型效果）
  - 比如是人工录入、文档拆分还是模型生成，是否需要审核和标记来源
- ② QA 的维护成本
  - 是否支持版本管理、修改留痕和回滚，避免知识在迭代过程中失控
- ③ QA 的使用情况
  - 包括检索方式、命中率，以及是否需要通过标签或权重来提升有效 QA 的命中
- ③ QA 质量反馈
  - 比如用户是否采纳答案、是否产生纠错反馈，用这些数据反过来优化 QA 本身。

#### 2、QA生命流程

一个 QA 是如何从创建 → 被使用 → 被淘汰的

<mark>一个 QA 的生命周期 = 创建 → 校验 → 入库 → 检索 → 命中 → 反馈 → 迭代 / 淘汰</mark>(请注意，完整的理解这条链路，才是懂不懂后端的关键)

- 业务真实场景里，QA 的来源通常只有几类：
  - 人工维护：运营 / 标注人员手动录入
  - 文档拆分：把制度、FAQ、说明文档拆成 QA
  - 模型生成：LLM 根据语料生成候选 QA

<mark>此时你需要意识到，不同来源 → 可信度不同 → 管理方式一定不同</mark>

### 引用

> [后端程序员的尊严，从学会 RESTful API 开始！](https://www.bilibili.com/video/BV1WFBXBmExs/?spm_id_from=333.337.search-card.all.click&vd_source=c108fb8f6c838d5d891d1da802282ab5)
