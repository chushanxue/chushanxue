> Talk is cheap, show me the code

### 一、什么是函数式编程

> 函数式编程的思维过程是完全不同的，它的着眼点是函数，而不是过程，它强调的是如何通过函数的组合变换去解决问题，而不是我通过写什么样的语句去解决问题，当你的代码越来越多的时候，这种函数的拆分和组合就会产生出强大的力量。

假设我们有这么个需求，我们登记了一系列人名存在数组中，现在需要对这个结构进行一些修改，需要把字符串数组变成一个对象数组，方便后续的扩展，并且需要把人名做一些转换：

```bash
['john-reese', 'harold-finch', 'sameen-shaw']
// 转换成
[{name: 'John Reese'}, {name: 'Harold Finch'}, {name: 'Sameen Shaw'}]
```

先不看大佬的解析，自己实现一遍：

```js
//上来先定义，而不是先方法，这是gpt教给我的
const originList = ['john-reese', 'harold-finch', 'sameen-shaw'];

const newList = originList.map((item) => {
  return {
    name: item.replace(/-/g, ' '), //注意这个name需要加引号，否则会被当成变量，这里md格式化自动去掉了引号....
  };
});

console.log(newList);
console.log(originList);
```

实际上，这已经是函数式编程了，鼓掌👏🏻，接下来看大佬的举例：

- 命令式编程

  用传统的编程思路，我们一上来就可以撸代码，临时变量，循环走起来：

  ```js
  // 这个编程思路很熟悉，以前在学C和JAVA的时候一定写过类似的代码
  const arr = ['john-reese', 'harold-finch', 'sameen-shaw'];
  const newArr = [];
  for (let i = 0, len = arr.length; i < len; i++) {
    let name = arr[i];
    let names = name.split('-');
    let newName = [];
    for (let j = 0, naemLen = names.length; j < naemLen; j++) {
      let nameItem = names[j][0].toUpperCase() + names[j].slice(1);
      newName.push(nameItem);
    }
    newArr.push({ name: newName.join(' ') });
  }
  return newArr;
  ```

  这几乎是所有人下意识的编程思路，完全的面向过程。你会想我需要依次完成：

  - 定义一个临时变量 newArr。
  - 我需要做一个循环。
  - 循环需要做 arr.length 次。
  - 每次把名字的首位取出来大写，然后拼接剩下的部分。
  - ……
  - 最后返回结果。

  这样当然能完成任务，最后的结果就是一堆**中间临时变量**，光想变量名就让人感到崩溃。同时过程中掺杂了大量逻辑，通常一个函数需要**从头读到尾才知道它具体做了什么**，而且一旦出问题很难定位。

  <mark>虽然这个例子自己避开了坑，但上述面向过程的思维并没有完全转变</mark>

- 函数式编程

  **函数式编程的着眼点是函数**，比如上述问题，我们把解决思路总结成函数：

  - 从 `String` 数组 到 `Object` 数组 的转换：`convertNames :: [String] -> [Object]`

    > Hindly Milner 类型签名 :: String -> Object这叫类型签名，最早是在 Hindley-Milner 类型系统中提出来的。引入它的好处显而易见，短短一行，就能暴露函数的行为和目的，方便我们了解语义。通过柯里化我们也能理解这种写法 :: Regex -> String -> String -> String 实际前面的都是参数，最后的才是输出，但要注意参数的顺序是有严格先后顺序的，因为后面的函数要依赖前面函数的输出（以后所有函数都写上函数签名，方便别人）

  - 至于这种转换，再细致拆分成两个函数：把名称转换成指定形式/把任意类型转换成对象

### 二、为什么叫函数式编程

函数即是一种描述集合和集合之间的转换关系，输入通过函数都会返回有且只有一个输出值。

所以，函数实际上是一个关系，或者说是一种映射，而这种映射关系是可以组合的，<mark>一旦我们知道一个函数的输出类型可以匹配另一个函数的输入，那他们就可以进行组合。</mark>

> 在我们的编程世界中，我们需要处理的其实也只有“数据”和“关系”，而关系就是函数。我们所谓的编程工作也不过就是在找一种映射关系，一旦关系找到了，问题就解决了，剩下的事情，就是让数据流过这种关系，然后转换成另一个数据罢了。

![ ](/md/函数式编程梳理/1.png)

### 三、函数式编程的特点

#### 1、声明式编程

函数式编程大多时候都是在声明我需要做什么，而非怎么去做。这种编程风格称为**声明式编程** 。这样有个好处是代码的可读性特别高，因为声明式代码大多都是接近自然语言的，同时，它解放了大量的人力，因为它不关心具体的实现，因此它可以把优化能力交给具体的实现，这也方便我们进行分工协作。

> SQL 语句就是声明式的，你无需关心 Select 语句是如何实现的，不同的数据库会去实现它自己的方法并且优化。React 也是声明式的，你只要描述你的 UI，接下来状态变化后 UI 如何更新，是 React 在运行时帮你处理的，而不是靠你自己去渲染和优化 diff 算法。

与声明式编程（`declarative`）对应的是命令式编程（`imperative`）

#### 2、惰性执行

函数只在需要的时候执行，即不产生无意义的中间变量。像刚才的例子，函数式编程跟命令式编程最大的区别就在于几乎没有中间变量，它从头到尾都在写函数，只有在最后的时候才产生实际的结果。

#### 3、无状态和数据不可变

这是函数式编程的核心概念：

- 数据不可变： 它要求你所有的数据都是不可变的，这意味着如果你想修改一个对象，那你应该**创建一个新的对象用来修改，而不是修改已有的对象**(这点以后要注意了)。
- 无状态： 主要是强调对于一个函数，不管你何时运行，它都应该像第一次运行一样，给定相同的输入，给出相同的输出，完全不依赖外部状态的变化。

为了实现这个目标，函数式编程提出函数应该具备的特性：没有副作用和纯函数。

![ ](/md/函数式编程梳理/2.png)

#### 4、没有副作用

副作用：在完成函数主要功能之外完成的其他副要功能

在函数中我们最常见的副作用就是**随意操纵外部变量**。

> 由于 JS 中对象传递的是引用地址，哪怕我们用 const 关键词声明对象，它依旧是可以变的。而正是这个“漏洞”让我们有机会随意修改对象。

例如： map 函数的本来功能是将输入的数组根据一个函数转换，生成一个新的数组：

`map :: [a] -> [b]`

而在 JS 中，我们经常可以看到下面这种对 map 的 “错误” 用法，把 map 当作一个循环语句，然后去直接修改数组中的值。

```js
const list = [...];
// 修改 list 中的 type 和 age
list.map(item => {
  item.type = 1;
  item.age++;
})
```

这样函数最主要的输出功能没有了，变成了直接修改了外部变量，这就是它的副作用。而没有副作用的写法应该是：

```js
const list = [...];
// 修改 list 中的 type 和 age  （其中的...item我感觉可要可不要，反正会被覆盖）
const newList = list.map(item => ({...item, type: 1, age:item.age + 1}));
```

> 保证函数没有副作用，一来能保证数据的不可变性，二来能避免很多因为共享状态带来的问题。当你一个人维护代码时候可能还不明显，但随着项目的迭代，项目参与人数增加，大家对同一变量的依赖和引用越来越多，这种问题会越来越严重。最终可能连维护者自己都不清楚变量到底是在哪里被改变而产生 Bug。

#### 5、纯函数

纯函数算是在 “没有副作用” 的要求上再进一步了。

其实纯函数的概念很简单就是两点：

- 不依赖外部状态（无状态）： 函数的的运行结果不依赖全局变量，this 指针，IO 操作等。

- 没有副作用（数据不变）： 不修改全局变量，不修改入参。

所以纯函数才是真正意义上的 “函数”， 它意味着相同的输入，永远会得到相同的输出。

举个开发中常见的例子，我们在请求列表数据的时候，有时候会把搜索参数放在外面，然后直接在函数中用，而不当做参数：

```js
  const getData = async (current: number, size: number) => {
    try {
      // 除了current和size，其他变量都是依赖外部变量，这意味着相同的输入并不一定产生相同的输出
      const data = await getTable({ current, size, requestSource, createTimeBegin, createTimeEnd });
      ...
    } catch (error) {
      console.log(error);
    }
  };
```

我们这么强调使用纯函数，纯函数的意义是什么？

- 便于测试和优化：这个意义在实际项目开发中意义非常大，由于纯函数对于相同的输入永远会返回相同的结果，因此我们可以轻松断言函数的执行结果，同时也可以保证函数的优化不会影响其他代码的执行。这十分符合测试驱动开发 TDD（Test-Driven Development）的思想，这样产生的代码往往健壮性更强。

- 可缓存性：因为相同的输入总是可以返回相同的输出，因此，我们可以提前缓存函数的执行结果（memoize 函数）。
- 自文档化：由于纯函数没有副作用，所以其依赖很明确，因此更易于观察和理解。
- 更少的 Bug：使用纯函数意味着你的函数中不存在指向不明的 this，不存在对全局变量的引用，不存在对参数的修改，这些共享状态往往是绝大多数 bug 的源头。

### 四、函数柯里化

柯里化的意思是将一个多元函数，转换成一个依次调用的单元函数。

`f(a,b,c) → f(a)(b)(c)`

学习函数柯里化之前，先复习一下中学数学中的高斯消元法：设函数 `f(x,y) = x + y`，在 `y = 1` 的时候，函数可以修改为 `f(x) = x + 1` 。基本思路就是把二元变成一元，同理我们可以把三元函数降元为二元，甚至把多元函数降元为一元函数。

> 柯里化强调的是生成单元函数，**部分函数应用**强调的是**固定任意元参数**，而我们平时生活中常用的其实是部分函数应用，这样的好处是可以固定参数，降低函数通用性，提高函数的适合用性。

#### 1、概念理解

函数柯里化（`Currying`）是一种在函数式编程中常见的技术，它的主要思想是将一个接受多个参数的函数转换为一系列使用一个参数的函数。

举个例子，假设我们有一个加法函数，它接受两个参数：

```js
function add(x, y) {
  return x + y;
}
```

我们可以调用这个函数并传入两个参数：`add(1, 2)`，结果是`3`。

现在，我们将这个函数柯里化：

```js
function curryAdd(x) {
  return function (y) {
    return x + y;
  };
}
```

现在我们有了一个新的加法函数`curryAdd`。但是，与原来的`add`函数不同，`curryAdd`只接受一个参数。当你调用`curryAdd(1)`时，它会返回一个新的函数。这个新的函数期待另一个参数，并且当你传入这个参数时（比如说`2`），它会返回最终结果（在这种情况下是`3`）。

所以你可以像下面这样使用柯里化后的加法函数：

```js
const addOne = curryAdd(1);
console.log(addOne(2)); // 输出：3
```

在上述代码中，首先调用了`curryAdd(1)`并将返回的函数存储在了`addOne`中。然后，在需要进行加法操作时，只需调用`addOne(2)`即可。

通过柯里化，我们可以<mark>创建预先配置了一些参数值（这部分参数以后永远不变）的新函数</mark>。这对于避免重复代码和增强代码可读性非常有帮助。

#### 2、实现柯里化

柯里化是函数式编程中不可或缺的一环，这个函数**使得接受多参数的函数可以通过不影响结果的方式使其成为接受单参数的函数及其序列**，根据这个特点可以合成出很多类似功能的函数，甚至是以自定义的顺序运行代码，达到复用代码的目的

下面我们来看一个例子

```js
// 求 a, b, c 三个数的和
function sum(a, b, c) {
  return a + b + c;
}
// 调用
sum(1, 2, 3); // 6
```

改写为柯里化函数

```js
function sum(a) {
  return function (b) {
    return function (c) {
      return a + b + c;
    };
  };
}
// 调用
let sum1 = sum(1);
let sum2 = sum1(2);
sum2(3); // 6
```

如果按照上面的方式去改造函数，势必会让开发者抓狂，这里的代码也并不简洁友好

在实际开发中我们可能更多的会借助成熟函数组件库进行柯里化改造，比如接下来要介绍的 Lodash 中的 curry 函数：

- 调用方法：`_.curry(fn)`
- 功能：创建一个函数，该函数接收一个或多个 `fn` 的参数，如果 `fn` 所需要的参数都被提供则执行 `fn` 并返回执行的结果。否则继续返回该函数并等待接收剩余的参数。
- 参数：需要柯里化的函数
- 返回值：柯里化后的函数

```js
import _ from 'lodash';
function sum(a, b, c) {
  return a + b + c;
}
const curried = _.curry(sum);
// 如果输入了全部的参数，则立即返回结果
console.log(curried(1, 2, 3)); // 6

//如果传入了部分的参数，此时它会返回当前函数，并且等待接收 sum 中的剩余参数
console.log(curried(1)(2, 3)); // 6
console.log(curried(1, 2)(3)); // 6
```

通过比较代码，发现`Lodash` 中的 `curry` 函数帮我们省去了刚刚繁杂的柯里化过程

#### 3、实际应用

我们工作中经常遇到各种需要正则校验的需求，例如在提交用户信息的时候校验手机号、邮箱等。

下面我们来封装一个校验函数

```js
// 非柯里化版本
function checkByRegExp(regExp, string) {
  return regExp.test(string);
}

checkByRegExp(/^1\d{10}$/, '15010001000'); // 校验电话号码
checkByRegExp(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/, 'test@163.com'); // 校验邮箱
```

在实际使用中，其实我们不需要去关注正则是如何匹配的，只需要使用更具体函数去分别校验手机号或者邮箱，这里就需要我们使用柯里化函数处理一下。

```js
//进行柯里化
let _check = curry(checkByRegExp);
//生成工具函数，验证电话号码
let checkCellPhone = _check(/^1\d{10}$/);
//生成工具函数，验证邮箱
let checkEmail = _check(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/);

checkCellPhone('18642838455'); // 校验电话号码
checkCellPhone('13109840560'); // 校验电话号码
checkCellPhone('13204061212'); // 校验电话号码

checkEmail('test@163.com'); // 校验邮箱
checkEmail('test@qq.com'); // 校验邮箱
checkEmail('test@gmail.com'); // 校验邮箱
```

这比我们拆分成多个方法更方便，也更高级！

### 五、函数组合

> 有众多单一目的的小程序，一个程序只实现一个功能，多个程序组合完成复杂任务。

函数组合的目的是将多个函数组合成一个函数

函数组合的好处显而易见，它让代码变得简单而富有可读性，同时通过不同的组合方式，我们可以轻易组合出其他常用函数，让我们的代码更具表现力

这一章听得云里雾里。。。容后再议

暂时，需要做到的就是：

- 多使用纯函数减少副作用的影响。
- 使用柯里化增加函数适用率。

### 六、引用

> [简明 JavaScript 函数式编程——入门篇](https://juejin.cn/post/6844903936378273799)[【深入理解】柯里化&手写 Lodash 中 curry 函数｜ 技术点评](https://www.pipipi.net/questions/12364.html)
