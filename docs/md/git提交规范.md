### 一、概念

#### 1、约定式提交

约定式提交（`conventional commits`）是一种针对 `commit message` 的约定，用于创建清晰的提交历史。

格式化的 `commit message`，有几个好处：

- 提供更多的历史信息，方便快速浏览。

  使用`git log HEAD --pretty=format:%s`命令可以显示所有的变动，每个 `commit` 占据一行。你只看行首，就知道某次 `commit` 的目的。

  ![ ](/md/git提交规范/1.png)

- 可以过滤某些 `commit`（比如文档改动），便于快速查找信息。

  命令：`git log HEAD --grep feat`

  > 这个命令的含义是查看当前分支（HEAD）中包含"feat"关键字的提交记录。它会显示所有满足条件的提交记录，包括**提交的哈希值、作者、日期和提交信息等。**

- 可以直接从 `commit` 生成 `Change log`。

  ![ ](http://www.ruanyifeng.com/blogimg/asset/2016/bg2016010603.png)

```bash
<type>[optional scope]: <description>
【scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，一般不填。】

type有如下几种：

feat：新功能（feature）
fix：修补bug
docs：文档（documentation）
style： 格式（不影响代码运行的变动）
refactor：重构（即不是新增功能，也不是修改bug的代码变动）
test：增加测试
chore：构建过程或辅助工具的变动

【如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test）建议是不要。】
```

#### 2、CHANGELOG

<mark>发布新版本时，用来说明与上一个版本差异的文档</mark>

CHANGELOG 是一个记录软件项目版本变更的文档或文件。它通常用于记录每个版本中的新增功能、修复的问题、改进和其他变更，以便用户和开发者能够了解软件项目的演进历史。

- [语义化版本](https://semver.org/lang/zh-CN/)

  版本格式：主版本号.次版本号.修订号，版本号递增规则如下：

  - 1、主版本号：当你做了不兼容的 API 修改，
  - 2、次版本号：当你做了向下兼容的功能性新增，
  - 3、修订号：当你做了向下兼容的问题修正。

  先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。

### 二、工具

- [commitizen](https://github.com/commitizen/cz-cli) 是一个撰写合格 `Commit message` 的工具。

  以后，凡是用到 `git commit` 命令，一律改为使用 `git cz`，这时，就会出现选项，用来生成符合格式的 `Commit message`。

- `cz-conventional-changelog` 是 `commitizen` 的一个适配器

  这里不是很理解如果没有这个适配器会是什么效果 ❓

```bash
npm install -g commitizen cz-conventional-changelog
echo '{ "path": "cz-conventional-changelog" }' > ~/.czrc
【该配置指定了 commitizen 使用的适配器路径为 cz-conventional-changelog】
```

### 三、技巧整理

#### 1、代码回退

已经提交了很多轮代码，但想拿到某个时间节点（已提交状态）的旧代码

> 重新解释下这个情况，某些历史代码在多次提交中已经消失不见了，但是由于业务需要又要找回这些代码，这个时候其实目的不是回退，而是找回，所以回退后不要提交，拿到目标代码就立即还原，所以这时的--hard无威胁

- 使用命令`git reset --hard xxx`，注意`--hard`是重点，如果不加上这个参数，会在`git`更改里混入新代码，导致处理起来不方便，所以直接暴力回退到想要的版本
- 然后把所需文件摘出来，随便存到一个地方，可以直接在项目里新增一个目录，这个目录不会影响到后续操作，但要注意及时删除
- 然后`git pull`，这一步还原到最新的代码状态
- 最后，重新把需要的旧代码粘过来，正常提交就可以了，这样就是无痛回退

#### 2、代码提交

有一个比较棘手的问题，就是感知不到本地代码修改，还没有找到好的解决方案

<mark>20240511更新</mark>：遇到一个相似的提交问题，`git pull`拉不到最新代码，`git push`又冲突，直接重新拉一个本地分支，删掉目前有问题的本地分支就可以了（注意有改动的代码可以先`git stash`存起来，换到新分支后再`git stash pop`）

#### 3、身份验证

换到另一台很久不用的电脑，想要操作远程仓库时，报了两个错，一个是**代理**的问题，解决完之后就是**仓库的密码不正确**问题

这个时候我们直接清除原来的账号密码信息重新输入一遍就可以了

命令是`git config http.emptyAuth true`

#### 4、git rebase

git rebase是Git整合变更的另一种方式，区别与git merge

merge也就是合并，这个概念很容易理解，我们从分支上拉取代码进行修改，再提交的时候，如果遇到了别人的修改，则把我们的修改和他们的修改合并一下。那么rebase中文译为变基是什么意思呢？首先要理解这个base，base也就是基础的意思，当我们从代码分支上获取代码的时候，我们就有了一个基础，也就是base，此后的修改我们都是在这个基础之上进行的，但是当我们需要提交修改的时候，遇到了别人的代码，变基这个操作就是在这个时候，我们不去合并别人的代码，而是直接把我们原先的基础变掉，变成以别人修改过后的新代码为基础，把我们的修改在这个新的基础之上重新进行。基础变掉了，所以叫作变基。

好处之一是可以使我们的时间线变得非常干净，以前采用合并的时候，时间线里完整记录了我们的代码是从哪个基础上拉取出来的，做了哪些修改，然后又在哪个时间点合并回分支去，而采用变基之后，时间线上不再反映拉取的时间点，因为每次提交都是以最新代码为基础的，所以时间线就变成了一根直线。

因为变基的操作原理是它需要先把你本地代码库里还没有推送的那部分提交反向释放到工作区，然后从服务器拉取新代码，再以新代码为基础把工作区里的修改附加上去，因为有这个过程，所以它必须要求你的服务区是干净的

其余要注意的就是有冲突的时候，如果有冲突，则合并完冲突之后，执行一下git rebase --continue就好了，其它和原先的用法没有任何区别。

git rebase 只能操作未 push 到远程的 commit（永远不要对已经推到主干分支服务器或者团队其他成员的提交进行变基，我们选择变基还是合并的范围应该在自己当前工作范围内。）

> 虽然很少用到这个命令，但最近经常看到，所以记录一下，其实道理很简单，比如本地有个分支dev_llt，远程也有个dev_llt，这两个分支一直合作得很好，完成了一个任务，但是commit比较频繁，比较零碎，而当把dev_llt分支上的任务变基到本地dev分支上，再推送到dev，这样所有的代码都会被很好地合并，且只保留一次commit。

#### 5、分支管理

这个操作日常经常用到，但是还没有记录过，所以也整理在这里

当我们新建一个仓库时，往往只有一个master分支，此时简单的做法是，在本地从master复刻一个dev分支，然后直接`push origin HEAD`，会自动在远程加一个分支

```bash
git checkout -b dev origin/master
git push origin HEAD
```

### 四、引用

> [Commit message 和 Change log 编写指南](http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html) [用Git久了，你会自动变基吗？](https://juejin.cn/post/7010390848584024101)
