## 一、标注相关

### 1、Canvas 渲染性能优化

**渲染压力来自数据组织方式，而不是 Canvas 本身**

在数据层，我们并不是把所有标注框当成一个平铺数组，而是 按业务标签/标注类型对标注数据进行分组和索引。一张图片可能有上千个标注框，但在任何一个真实操作场景下，用户关注的其实只是某一个标签或某一类业务数据，因此我们在状态层只维护「当前激活标签」对应的标注集合。Canvas 渲染层只订阅这一小部分数据，避免一次性把 1000 个标注对象全部实例化和绘制，从源头降低渲染压力

> 每张图片的标注数据在内存中是一个以 labelId 为 key 的 Map 或对象索引，而不是一个扁平数组。这样在切换标签时，能直接 O(1) 拿到对应的标注集合，而不是在 1000 条数据里反复 filter。（当然了实际的方式是每次切换标签，都会去进行请求，和一次拿回所有数据，然后前端自行匹配的方案各有优劣）

当然，在这之前也调研过常见的性能优化手段，比如**离屏渲染、脏区渲染、异步渲染**等等，出于迭代周期的把控和现有业务的需求，没有深入探索

### 2、fabric.js

Fabric 本质上是“对象化的 Canvas”，但性能边界仍然取决于对象数量和重绘策略

### 3、Canvas 是怎么处理重绘的？你们如何避免无效重绘？

Canvas 是“全量重绘”模型

- 控制进入渲染层的对象数量（你已经做了）
- 批量更新
- 拖拽时关闭非必要监听

### 4、Canvas 缩放、拖拽时如何保证精度（坐标转换体系）

在图像标注场景中，我区分了 **屏幕坐标**、Canvas 坐标、图片原始坐标 三套坐标体系。

所有交互发生在屏幕坐标系，但绘制与状态维护统一在世界坐标系，最终与后端交互时再映射回图片原始坐标，从而保证在缩放、拖拽、多分辨率下标注精度不丢失。

> 单独讲讲缩放：当以鼠标点为缩放中心时，Canvas 会产生隐式位移，通过维护一套**反向位移量**，把屏幕变化重新映射回世界坐标，保证鼠标下的点在世界坐标中不发生跳变。

- 屏幕坐标

  捕获用户真实鼠标位置/缩放时的锚点（zoomToPoint）

  ```js
  e.e.offsetX;
  e.e.offsetY;
  e.e.clientX;
  e.e.clientY;
  ```

- Canvas 世界坐标（你真正“画图”的坐标）

  把“被缩放 + 被平移后的屏幕坐标”，反解回一个稳定的世界坐标

  > 我们所说的 Canvas 世界坐标，是指 Fabric 内部对象使用的**逻辑坐标系**，它和 DOM 像素坐标**解耦**，通过 viewportTransform 映射到屏幕上。

  ```js
  const transformMouse = (mouseX, mouseY) => {
    return {
      x: mouseX / state.zoom - state.moveX,
      y: mouseY / state.zoom - state.moveY,
    };
  };
  ```

- 图片原始坐标（后端 & 模型使用的坐标）

  统一还原为“以图片中心为原点、按原图比例”的坐标体系,保证了：不同 canvas 尺寸、不同缩放倍数、不同分辨率显示标注数据永远一致

  `(x - state.left - imgWidth / 2) / state.ratio`

### 5、标注数据是怎么和后端对齐的

在标注工具中，设计了三层坐标体系。

用户事件来自**屏幕坐标**，但所有绘制和状态计算都统一转换到 **Canvas 世界坐标**，通过 zoom 和 moveX/moveY 做**反向映射**，避免缩放和平移导致精度丢失。

最终与后端交互时，再通过 ratio 和图片边界信息，将标注还原为基于原始图片的坐标，从而保证在任意缩放、拖拽、重绘场景下，数据始终一致。

### 6、如何处理标注的撤销 / 重做

history数组

`const record = state.history[state.history.length - 1];`

## 二、原理相关

### 1、canvas 与 svg 在可视化领域优劣如何

在可视化领域，`<canvas>` 和 `<svg>` 是两种常用的图形绘制技术，各有其优劣。它们各自适用于不同的场景和需求。

- Canvas
  - 性能高效：对于需要频繁更新的动态内容（如游戏、动画），`<canvas>` 更加高效。因为它基于像素渲染，不需要管理复杂的 DOM 树。
  - 复杂绘制：适合绘制复杂的图形和图像操作，如实时图像处理、像素级别的操作等。
  - 适合：动画和游戏。实时数据可视化（如图表的动态更新）。图像处理和像素级操作。复杂的图形和渲染效果。
- SVG
  - 可维护性：SVG 是基于 XML 的矢量图形，图形元素在 DOM 中可以直接访问和操作。可以使用 CSS 和 JavaScript 进行样式和事件处理。
  - 可缩放性：SVG 图形是矢量的，可以在不同分辨率和尺寸下清晰显示，不会失真。
  - 适合：图标和标志设计。矢量图形和图表（如静态和交互式图表）。响应式和可缩放的图形设计。
