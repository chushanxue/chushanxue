### 一、前言

![ ](/md/渲染流水线/1.webp)

从图中可以看出，左边输入的是 HTML、CSS、JavaScript 数据，这些数据经过中间渲染模块的处理，最终输出为屏幕上的像素。这中间的渲染模块就是我们本文要讨论的主题。

由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线。

按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局、分层、绘制、（分块、光栅化）和合成。

- 开始每个子阶段都有其输入的内容。
- 然后每个子阶段有其处理过程。
- 最终每个子阶段会生成输出内容。

### 二、渲染流程

#### 1、构建 DOM 树

为什么要构建 DOM 树呢？这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。

#### 2、样式计算

样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。

- 把CSS转换为浏览器能够理解的结构

  和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本装换为浏览器可以理解的结构——**styleSheets**。

- 转换样式表中的属性值，使其标准化

  比如：2em 被解析成了 32px，red 被解析成了 rgb(255, 0, 0)，bold 被解析成了 700...

- 计算出DOM树中每个节点的具体样式

  - 涉及到 CSS 的继承规则和层叠规则
  - UserAgent 样式，它是浏览器提供的一组默认样式，如果你不提供任何样式，默认使用的就是 UserAgent 样式。

#### 3、布局

现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。那么接下来就需要计算出 DOM 树中可见元素的几何信息，我们把这个计算过程叫做布局。

Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。

- 创建布局树

  - 遍历 DOM 树中的所有可见节点，并把这些节点加到布局中。
  - 而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 display: none，所以这个元素也没有被包进布局树。

- 布局计算

  计算布局树节点的坐标位置

  > 在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树即是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。

#### 4、分层

<mark>元素有了层叠上下文的属性或者需要被剪裁，满足这任意一点，就会被提升成为单独一层。</mark>

现在我们有了布局树，而且每个元素的具体位置信息都计算出来了，那么接下来是不是就要开始着手绘制页面了？

答案依然是否定的。

因为页面中有很多复杂的效果，如一些复杂的3D变换、页面滚动，或者使用 z-index 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。如果你熟悉 PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。

通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的图层，那么这个节点就从属于父节点的图层。如上图的 span 标签没有专属的图层，那么它们就从属于它们的父节点图层。但不管怎样，最终每一个节点都会直接或者间接地从属于一个层。

那么满足什么条件，渲染引擎才会为特定的节点创建新的层呢？通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。

- 拥有层叠上下文属性的元素会被提升为单独的一层

  明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。

- 需要剪裁（clip）的地方也会被创建为图层

  比如我们把 div 的大小限定为 200 * 200 像素，而 div 里面的文字内容比较多，文字所显示的区域肯定会超过 200 *200 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 div 区域，出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。

#### 5、绘制

在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制，具体是把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表

绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些待绘制列表。

绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。

#### 6、合成

要知道接下来合成线程是怎么工作的，我们得先来看看什么是视口：<mark>通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。</mark>

在有些情况下，有些图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。

基于这个原因，合成线程会将图层划分为图块（tile），这些图块的大小通常是 256 * 256 或者 512 *512

然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由**栅格化**来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。

通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——"DrawQuad"，然后将该命令提交给浏览器进程。

浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

#### 7、总结

一个完整的渲染流程大致可总结为如下：

- 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。

- 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。

- 创建布局树，并计算出 DOM 节点的样式。

- 对布局树进行分层，并生成分层树。

- 为每个图层生成绘制列表，并将其提交到合成线程。

- 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。

- 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。

- 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

### 三、根据渲染过程谈谈优化

#### 1、关于重排和重绘、合成

- 更新了元素的几何属性（重排）

  如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。

- 更新了元素的绘制属性（重绘）

  如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。

- 直接合成阶段

  使用 CSS 的 transform（一个既不要布局也不要绘制的属性）来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。

#### 2、如何优化 DOM 树解析过程

- 简化 HTML 结构（减少节点嵌套、去除冗余元素）
- CSS放在头部，JS放在底部，以避免阻塞渲染
- 使用虚拟DOM

#### 3、关于样式计算阶段的优化

- 使用简单的CSS选择器，避免使用过于复杂的嵌套选择器
- 减少动态样式变更（尽量减少使用 JavaScript 动态修改样式的频率，这些操作会触发浏览器的重排和重绘。）

#### 4、关于布局阶段的优化

布局阶段开销比较大，需要尽量减少触发布局的次数。

- 使用 flex / grid 合理布局

#### 5、关于绘制阶段的优化

- 减少复杂阴影、渐变

### 引用

> [渲染流程（上）：HTML、CSS和JavaScript是如何变成页面的](https://github.com/w-l-l/BrowserPrinciple/blob/main/%E5%AE%8F%E8%A7%82%E8%A7%86%E8%A7%92%E4%B8%8A%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9AHTML%E3%80%81CSS%E5%92%8CJavaScript%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E6%88%90%E9%A1%B5%E9%9D%A2%E7%9A%84/index.md)
