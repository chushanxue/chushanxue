### 一、断流问题分析

在流式输出的过程中，有三种情况前端会停止输出：

- 明确给出done标识
- 网络异常
- 解析数据结构失败

### 二、思路

后端给的数据结构是固定的，都是data对象，每一次可能收到多个data对象，拆分出来后，就可以拆解中间我们需要的字段

当我们存储流式数据时，start标志是实现流式的核心，一旦有了start标志，就新开一个对象去接受它，start的后面的数据都陆续写入改对象，直到新的start出现，type是UI展示的核心，不同的type展示的位置和性质不一样，这也是agent实现的核心

### 三、具体代码

```js
// 使用换行符 \n 拆分原始数据，并过滤掉空字符串元素
const dataStrings = text.split('\n').filter((line) => line.trim() !== '');

// 去除"data:"前缀，并解析字符串数组为 JSON 对象数组
// 注意，能解析为正常对象的才解析，所以需要isJSON方法（注意这一步还没有剔除null）
const dataArray = dataStrings.map((dataString) => {
  const trimmedDataString = dataString.replace('data:', '').trim();
  return isJSON(trimmedDataString) ? JSON.parse(trimmedDataString) : null;
});

// 开始解析对象数组
for (let item of dataArray) {
  // 绕过null
  if (item === null) {
    continue;
  }
  // 与后端约定的结束标志
  if (item.event === 'end') {
    //结束整体的解析
    ...
  }
  // 与后端约定的消息开始标志
  if (item.event === 'message_start') {
    addResponseStart({
      content: item.content,
      type: item.type,
      answerId: item.answerId,
    });
  }
  // 与后端约定的消息中间标志（其实没有必要有结束标志，有开始标志就可以了）
  else if (item.event === 'message' || item.event === 'message_end') {
    addResponse({
      content: item.content,
      type: item.type,
      answerId: item.answerId,
    });
  }
}
```

```js
// 判断一个字符串是否为 JSON 格式
export const isJSON = (str: string) => {
  if (typeof str === 'string') {
    try {
      let obj = JSON.parse(str);
      if (typeof obj === 'object' && obj) {
        return true;
      } else {
        return false;
      }
    } catch (e) {
      return false;
    }
  }
  return false;
};

```
