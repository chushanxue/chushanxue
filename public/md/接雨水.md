### 一、题目

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

![ ](/md/接雨水/0.png)

### 二、解题思路

题意倒是好懂，思路是一点没有

这道题有多种解法，层层递进，适合全盘总结

### 三、正确答案

黑色的看成墙，蓝色的看成水，宽度一样，给定一个数组，每个数代表从左到右墙的高度，求出能装多少单位的水。也就是图中蓝色正方形的个数。

#### 1、解法一：按行求（了解即可）

求第 i 层的水，遍历每个位置，如果当前的高度小于 i，并且两边有高度大于等于 i 的，说明这个地方一定有水，水就可以加 1。

![ ](/md/接雨水/1.png) ![ ](/md/接雨水/2.png) ![ ](/md/接雨水/3.png)

```js
/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function (height) {
  const maxNum = Math.max(...height); //求数组中的最大元素
  let ans = 0; //总共存的水
  for (let i = 1; i < maxNum + 1; i++) {
    //i代表第i行
    let flag = false; //是否开始接水
    let temp = 0; // 当前存储的水
    for (let j = 0; j < height.length; j++) {
      // 是否可以开始接水(每一层只触发一次，因为按照上图，只有右侧有墙也是无法接水的，这一步是保证左侧也有墙)
      // 不等式的含义是本列有墙
      if (height[j] >= i) {
        flag = true;
      }
      // 确保可以接水才开始接水
      if (flag) {
        //不等式的含义是本列没有墙
        if (height[j] < i) {
          temp++; // 当前储水量增加（注意没遇到右边那堵墙前不会把这个储水量算到总量中去）
        } else {
          // 遇到了右边那堵墙
          ans += temp;
          temp = 0;
        }
      }
    }
    console.log(`第${i}行:接水量${ans}`);
  }

  return ans;
};
```

#### 2、解法二：按列求（更推荐）

①求每一列的水，我们只需要关注当前列的高度，以及左边最高的墙的高度，右边最高的墙的高度就够了。(**此种解法难点是要求出左边最高的墙和右边最高的墙**)

这样我们就需要两个额外数组（原本的数组已给出当前列的高度），分别存储该列左边最高的墙的高度和右边最高的墙的高度。（我们可以称之为前缀最大值和后缀最大值）

前缀数组的求法，就是遍历数组，每个前缀最大值都等于它上一个前缀最大值和当前高度取max，后缀最大值同理

②装水的多少，当然根据木桶效应，我们只需要看左边最高的墙和右边最高的墙中较矮的一个就够了。所以，根据较矮的那个墙和当前列的墙的高度可以算出`当前列的储水量=较矮墙的高度-当前列的高度`

我们在求出两个额外数列，及计算答案都是一次遍历（无嵌套遍历），所以时间复杂度为 O(n)

![ ](/md/接雨水/4.png)

```js
var trap = function (height) {
  let n = height.length;
  let pre_max = [];
  pre_max[0] = height[0];
  let suf_max = [];
  suf_max[n - 1] = height[n - 1];
  let sum = 0; //储水量
  // 注意前两个遍历的起始位置，以及初始数组的赋值位置
  for (let i = 1; i < n; i++) {
    pre_max[i] = Math.max(pre_max[i - 1], height[i]);
  }
  // let i in height这种写法无法倒序遍历，所以用回最原始的
  for (let i = n - 2; i >= 0; i--) {
    suf_max[i] = Math.max(suf_max[i + 1], height[i]);
  }
  // 注意这里是min
  for (let i in height) {
    sum += Math.min(pre_max[i], suf_max[i]) - height[i];
  }
  return sum;
};
```
