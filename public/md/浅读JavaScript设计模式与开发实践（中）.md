## 二、基础知识

### 5、闭包

对于 `JavaScript` 程序员来说，闭包（`closure`）是一个难懂又必须征服的概念。**闭包的形成与变量的作用域以及变量的生存周期密切相关**。

官方概念：一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域

简单理解：闭包 = 内层函数 + 引用的外层函数变量

#### ① 变量的作用域

`JavaScript` 中，函数可以用来创造函数作用域。此时的函数像一层半透明的玻璃，**在函数里面可以看到外面的变量，而在函数外面则无法看到函数里面的变量**。这是因为当在函数中搜索一个变量的时候，如果该函数内并没有声明这个变量，那么此次搜索的过程会随着代码执行环境创建的作用域链往外层逐层搜索，一直搜索到全局对象为止（<mark>Javascript 语言特有的"链式作用域"结构（chain scope）</mark>）。**变量的搜索是从内到外而非从外到内的**。

<mark>函数内部声明变量的时候，一定要使用（let/const/var）命令。如果不用的话，你实际上声明了一个全局变量</mark>

```js
// 变量搜索的过程
var a = 1;
var func1 = function () {
  var b = 2;
  var func2 = function () {
    var c = 3;
    alert(b); // 输出：2
    alert(a); // 输出：1
  };
  func2();
  alert(c); // 输出：Uncaught ReferenceError: c is not defined
};
func1();
```

#### ② 变量的生存周期

对于全局变量来说，全局变量的生存周期当然是永久的，除非我们主动销毁这个全局变量

而对于在函数内声明的局部变量来说，当退出函数时，这些局部变量即失去了它们的价值，它们都会随着函数调用的结束而被销毁

#### ③ 闭包的作用

- 封装变量（变量私有化）

  闭包可以帮助把一些不需要暴露在全局的变量封装成“私有变量”（避免这些变量被外部随意改动）。

- 延续局部变量的寿命/捕获

  说起来，这两个作用好像都是不太好的作用

  - 延续变量是其一，我们说的**内存泄漏**指的就是这个变量，一般的函数执行完了，里面的变量会被销毁，但如果通过闭包引用到了该变量，该变量就跟全局变量的周期保持一致

    ```js
    function outerFunction() {
      let outerVariable = 'I am outside!';

      function innerFunction() {
        console.log(outerVariable); // 访问外部函数的变量
      }

      return innerFunction;
    }

    let myInnerFunction = outerFunction();
    myInnerFunction(); // 输出: 'I am outside!'
    ```

    在上述代码中，`innerFunction` 是一个闭包。尽管 `outerFunction` 已经执行完毕，但 `innerFunction` 仍然可以访问 `outerVariable`。 这是因为当 `innerFunction` 被创建时，它保存了一个指向 `outerFunction` 的作用域的引用。

  - 捕获则更为重要，闭包在创建时会捕获当时的变量，且捕获后不会形成双向绑定，也就是这里的值被“空间暂停”了，这里暂时不作例子，在`react`的使用中，会经常遇到这种情况，比如定时器，比如事件监听（都与`useEffect`有关）

### 6、var、let、const

- 补充一个知识点：[立即调用函数表达式](https://developer.mozilla.org/zh-CN/docs/Glossary/IIFE)（也被称为自执行匿名函数/ IIFE 模式）

  ```js
  括号里可以传参（注意同步传参，不要只把参数丢在最后的括号里就不管了，前面的括号里要先声明）
  (function () {
    // …
  })();

  (() => {
    // …
  })();

  (async () => {
    // …
  })();
  ```

理解闭包的时候，有很多经典例子其实已经可以用更现代的方法解决，比如以下代码：

```js
每隔3秒输出6;
for (var i = 0; i <= 5; i++) {
  //是由于定时器的影响
  setTimeout(() => {
    console.log(i);
  }, i * 3000);
}

我们希望的结果当然是每隔3秒输出0123456;


所以，来，上闭包，问题迎刃而解
for (var i = 0; i <= 5; i++) {
//套了个IIFE函数把参数传递进去
((i)=>setTimeout(() => {
  console.log(i);
}, i * 3000))(i);
}

```

但我们不用闭包，直接把 `var` 换成 `let`，问题一样迎刃而解，这是为什么呢

> 当我们使用 var 时，它会声明全局或函数级别的变量，并且**该变量的值可以被同一作用域下的所有代码访问**。 在函数中，例如 for 循环中，变量 i 会覆盖之前的整个循环，即使定时器被触发并且循环已经结束也是如此。 这就是为什么 setTimeout 中的代码输出都是 6。而使用 let 可以避免这种情况。 let 声明的变量具有**块级作用域**， **每次迭代时，let i 的值仅适用于该迭代的当前范围内的代码**。

所以，接下来捋一捋 `let const var` 的区别与联系

<mark>首先，请明确一点，let 与 const 是为了解决 var 存在的一些问题，为了替代它而出现的，所以这三者不要混着用</mark>

`var` 存在以下问题：

- `var` 的作用域
- `var` 变量可以重新声明和更新
- `var` 的提升

`let` 现在是变量声明的首选。这并不奇怪，因为它是对 `var` 声明的改进，解决了我们刚刚介绍的 `var` 的问题。

- `let` 是块作用域

  块是由 {} 界定的代码块。一个块存在于花括号中。花括号内的任何内容都是一个块。

- `let` 可以更新但不能重新声明
- `let` 无法提升

用 `const` 声明的变量保持恒定值。 `const` 声明与 `let` 声明基本一致，除了不能重新赋值（当然如果涉及到变量，虽然无法更新 `const` 对象，但可以更新此对象的属性）

### 7、高阶函数

#### ①、概念

高阶函数是指至少满足下列条件之一的函数。

- 函数可以作为参数被传递（将函数当作参数传递）

  把函数当作参数传递，这代表我们可以**抽离出一部分容易变化的业务逻辑，把这部分业务逻辑放在函数参数中，这样一来可以分离业务代码中变化与不变的部分。**

  ```js
  最典型的应用就是回调函数;

  // xxx为接口请求方法，执行的时候，将一个回调函数作为它的参数，待请求完成之后执行回调函数
  await xxx((res) => {
    console.log('接口请求成功', res);
  });
  ```

  回调函数的应用不仅只在异步请求中，当一个函数不适合执行一些请求时，我们也可以**把这些请求封装成一个函数，并把它作为参数传递给另外一个函数，“委托”给另外一个函数来执行**。

  ```js
  直接用原书的例子：
  在页面中创建 100 个 div 节点，然后把这些 div 节点都设置为隐藏

  这是一个难以复用的函数，因为并不是每个人创建了节点之后就希望它们立刻被隐藏。
  于是我们把 div.style.display = 'none'这行代码抽出来，用回调函数的形式传入 appendDiv方法
  var appendDiv = function (callback) {
    for (var i = 0; i < 100; i++) {
      var div = document.createElement('div');
      div.innerHTML = i;
      document.body.appendChild(div);
      if (typeof callback === 'function') {
        callback(div);
      }
    }
  };
  appendDiv(function (node) {
    node.style.display = 'none';
  });
  ```

- 函数可以作为返回值输出（让函数的执行结果返回另外一个函数）

  让函数继续返回一个可执行的函数，意味着运算过程是可延续的。（感觉是封装的封装）

  ```js
  判断一个数据是否是某类型;
  var isType = function (type) {
    return function (obj) {
      return Object.prototype.toString.call(obj) === '[object ' + type + ']';
    };
  };

  var isString = isType('String'); //新的函数诞生
  var isArray = isType('Array');
  var isNumber = isType('Number');
  console.log(isArray([1, 2, 3])); // 输出：true
  ```

#### ②、应用

- 高阶函数实现 AOP

  > AOP（面向切面编程）的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来之后，再通过“动态织入”的方式掺入业务逻辑模块中。这样做的好处首先是可以保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块。

  在前端的常见需求中，有以下一些业务可以使用 AOP 将其从核心关注点中分离出来（避免侵入到业务代码中）

  - Node.js 日志 log
  - 埋点、数据上报
  - 性能分析、统计函数执行时间
  - 给 ajax 请求动态添加参数、动态改变函数参数
  - 分离表单请求和验证
  - 防抖与节流（防抖是在事件停止触发一段时间后执行回调，节流是在事件持续触发时以一定的时间间隔去定时执行回调）

  通常，在 `JavaScript` 中实现 `AOP`，都是指把一个函数“动态织入”到另外一个函数之中

  这种使用 `AOP` 的方式来给函数添加职责，也是 `JavaScript` 语言中一种非常特别和巧妙的装饰者模式实现（在 `ES6+` 之前，要使用装饰器模式，通常通过 `Function.prototype.before` 做前置装饰，和 `Function.prototype.after` 做后置装饰，`ES6` 引入了 `Decorator` ）

  ❓ 这里有点复杂，留到以后使用的时候再去研究
